#1、程序计数器
    线程私有
    当前线程所执行的字节码的行号指示器
    此区域是唯一一个在《Java虚拟机规范》中没有规定任何OutOfMemoryError情况的区域。
#2、Java虚拟机栈
     线程私有
     每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧用于存储局部变量表、操作数栈、动态连接、方法出口等信息。
     每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。
     
     对这个内存区域规定了两类异常状况：
         如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；
         如果Java虚拟机栈容量可以动态扩展[2]，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常。
#3、本地方法栈
    本地方法栈则是为虚拟机使用到的本地（Native）方法服务
    
    本地方法栈也会在栈深度溢出或者栈扩展失败时分别抛出StackOverflowError和OutOfMemoryError异常。
    
#4、Java堆
    线程共享
    Java世界里“几乎”所有的对象实例都在这里分配内存。
    Java堆是垃圾收集器管理的内存区域。将Java堆细分的目的只是为了更好地回收内存，或者更快地分配内存
    
    有时候给堆分代，也是实现类的一种（分代收集GC）
    
#5、方法区
    线程共享
    存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据    
    
    jdk8之前，Hotspot虚拟机把分代设计扩展至方法区，所以有些人把方法区和永久代混为一谈。
    方法区是接口，永久代是实现的一种。

    JDK 8，完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间（Metaspace）来代替
    
    如果方法区无法满足新的内存分配需求时，将抛出OutOfMemoryError异常。
    
    运行时常量池
        运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中有一项信息是【常量池表】，
        用于存放编译期生成的各种【字面量与符号引用】，这部分内容将在类加载后存放到方法区的运行时常量池中。
        
        常量池并非只有编译器才能产生，运行期间也可以。例如string的intern()方法。
        
#6、直接内存
    直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。
    
    在JDK 1.4中新加入了NIO（New Input/Output）类，它可以使用Native函数库直接分配堆外内存，
    通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。
    这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。
