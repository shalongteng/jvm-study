#1、引用计数算法
    有一个对象引用他，计数器加一。 当引用失效时，计数器值就减一；
    很难解决对象之间相互循环引用的问题。
#2、可达性分析算法
    “GC Roots”根对象
        虚拟机栈中引用的对象
        静态变量
        常量池中的引用
        所有被同步锁（synchronized关键字）持有的对象。
    如果某个对象到GC Roots间没有任何引用链相连，则证明此对象是不可能再被使用的。
#3、再谈引用
    强引用（Strongly Reference）、
    软引用（Soft Reference）、
        在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，
    弱引用（Weak Reference）
        被弱引用关联的对象只能生存到下一次垃圾收集发生为止。
    虚引用（Phantom Reference）
        为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。
#4、生存还是死亡？
    即使在可达性分析算法中判定为不可达的对象，也不是“非死不可”的，要真正宣告一个对象死亡，至少要经历两次标记过程
    
    对象不可达，那它将会被第一次标记，随后进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。
    假如对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，那么虚拟机将这两种情况都视为“没有必要执行”。
   
    finalize()方法是对象逃脱死亡命运的最后一次机会，稍后收集器将对F-Queue中的对象进行第二次小规模的标记
  
#5、回收方法区
    废弃的常量
    不再使用的类型。 类型卸载
