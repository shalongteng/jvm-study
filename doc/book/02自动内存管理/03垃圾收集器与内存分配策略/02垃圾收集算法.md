#1、分代收集理论
    三条假说：
    1）弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的。
    2）强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以消亡。
    3）跨代引用假说（Intergenerational Reference Hypothesis）：跨代引用相对于同代引用来说仅占极少数。
    
    新生代     Minor GC、Young GC
    老年代     Major GC/Old GC
    
    问题：
        对象不是孤立的，对象之间会存在跨代引用。
    解决方法：
        依据第3条假说，我们就不应再为了少量的跨代引用去扫描整个老年代，只需在新生代上建立一个全局的数据结构
        （该结构被称为“记忆集”，Remembered Set），这个结构把老年代划分成若干小块，标识出老年代的哪一块内存会
        存在跨代引用。此后当发生Minor GC时，只有包含了跨代引用的小块内存里的对象才会被加入到GCRoots进行扫描。
        
        
    部分收集（Partial GC）：指目标不是完整收集整个Java堆的垃圾收集，其中又分为：
        ■新生代收集（Minor GC/Young GC）：指目标只是新生代的垃圾收集。
        ■老年代收集（Major GC/Old GC）：指目标只是老年代的垃圾收集。目前只有CMS收集器会有单独收集老年代的行为。
        ■混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收集器会有这种行为。
    整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集。
    
#2、标记-清除算法
    算法分为“标记”和“清除”两个阶段
        标记那些对象是不可达的
        清除这些对象
    缺点：
        第一个是执行效率不稳定
        第二个是内存空间的碎片化问题
        
#3、标记-复制算法
    为了解决标记-清除算法面对大量可回收对象时执行效率低的问题
    
    内存分两块
        一半留着不用，一半使用。将使用的一半标记存活的对象。将存活的对象复制到空闲的区域。
        
    缺点：
        浪费空间
    
    进阶版：Appel式回收 8:1:1
        Eden空间
            每次分配内存只使用Eden和其中一块Survivor,垃圾收集时，将Eden和Survivor中仍然存活的对象复制到另一块Survivor空间上
        from Survivor
        to Survivor
        
    老年代分配担保
        直接进入老年代
        
#4、标记-整理算法
    不同于标记复制算法，不需要内存分块。
    
    老年代使用 标记-整理
    
    HotSpot虚拟机里面关注吞吐量的ParallelScavenge收集器是基于标记-整理算法的，
    而关注延迟的CMS收集器则是基于标记-清除算法的，
    
    吞吐量的实质是对象分配速率和垃圾收集器速率总和
