#1、根节点枚举 （找出根节点）
    调用栈里的引用类型数据是GC的根集合的重要组成部分，找出栈上的引用是GC的根枚举中不可或缺的一环。
    
    现在可达性分析算法耗时最长的查找引用链的过程已经可以做到与用户线程一起并发，
    但根节点枚举始终还是必须在一个能保障一致性的快照中才得以进行.所以这一步必须暂停用户线程。
    
    当用户线程停顿下来之后，其实并不需要一个不漏地检查完所有执行上下文和全局的引用位置，
    在HotSpot虚拟机里，是使用一组称为OopMap的数据结构来达到这个目的（这个oopMap 放的就是根节点引用）
        
    可以把oopMap简单理解成是调试信息。 在源代码里面每个变量都是有类型的，但是编译之后的代码就只有变量在栈上的位置了。
    oopMap就是一个附加的信息，告诉你栈上哪个位置本来是个什么东西
#2、安全点   safe point
    stw停业务线程时候，不是说所有的立马停止，因为有的线程正在对对象上锁呢，上了一半，这时候他不能停止。
    线程得停到一个合适的位置，停下来的时候，不会对前后的一致性产生影响。
    
    导致OopMap内容变化的指令非常多，
    
    实际上HotSpot也的确没有为每条指令都生成OopMap，前面已经提到，只是在“特定的位置”记录了这些信息，
    这些位置被称为安全点（Safepoint），用户线程强制达到安全点才能暂停。
    
    
    如何在垃圾收集发生时让所有线程（这里其实不包括执行JNI调用的线程）都跑到最近的安全点，然后停顿下来。
        抢先式中断 ： 系统主动中断用户线程，用户线程中断后，发现不在安全点自己跑到安全点
        主动式中断 ： 设一个标志位，线程去安全点轮询。如果需要中断则中断。
#3、安全区域
    用户线程处于Sleep状态或者Blocked状态，这时候线程无法响应虚拟机的中断请求。
    
    安全区域是指能够确保在某一段代码片段之中，引用关系不会发生变化，在这个区域中任意地方开始垃圾收集都是安全的。
    
    当线程要离开安全区域时，它要检查虚拟机是否已经完成了根节点枚举（或者垃圾收集过程中其他需要暂停用户线程的
    阶段），如果完成了，那线程就当作没事发生过，继续执行；否则它就必须一直等待，直到收到可以离开安全区域的信号为止。
    
#4、记忆集与卡表
    为解决对象跨代引用所带来的问题，垃圾收集器在新生代中建立了名为记忆集（Remembered Set）的数据结构，
    用以避免把整个老年代加进GC Roots扫描范围。它存放在收集区域。
    
    记忆集是一种用于记录从非收集区域指向收集区域的指针集合的数据结构，收集器只需要通过记忆集
    判断出某一块非收集区域是否存在有指向了收集区域的指针就可以了
    
    记录精度：
        ·字长精度：每个记录精确到一个机器字长（这个精度决定了机器访问物理内存地址的指针长度），该字包含跨代指针。
        ·对象精度：每个记录精确到一个对象，该对象里有字段含有跨代指针。
        ·卡精度：每个记录精确到一块内存区域，该区域内有对象含有跨代指针。
        
    第三种“卡精度”所指的是用一种称为“卡表”（Card Table）的方式去实现记忆集
        字节数组CARD_TABLE的每一个元素都对应着其标识的内存区域中一块特定大小的内存块，称作“卡页”（Card Page）512 字节
        
        收集区的每512个字节，对应一个卡页。卡页中只要有一个对象被其他区域对象所引用，对应卡表元素的值就变成1，也就是所谓的元素变脏。
        只要筛选出卡表中变脏的元素，把它们加入GC Roots中一并扫描。
#5、写屏障，（Write Barrier）读屏障
    在HotSpot虚拟机里是通过写屏障（Write Barrier）技术维护卡表状态的。
    
    写屏障可以看作在虚拟机层面对“引用类型字段赋值”这个动作的AOP切 面，更新卡表，对卡表进行维护。
    
    写前屏障（Pre-Write Barrier）  G1
    写后屏障（Post-Write Barrier） CMS
    
    当发现jvm在执行某一种操作时候，跟上去做一中背后的操作。在复制算法中。A-->B 这时候拷贝B对象到 另一个区域时候，
    需要把A重新指向B，任何一次垃圾移动对象以后都得更新引用，需要同步更新引用（写后屏障）
    
    “伪共享”（False Sharing）问题
        卡表在高并发场景下还面临着“伪共享”问题。伪共享是处理并发底层细节时一种经常需要考虑的问题，
        现代中央处理器的缓存系统中是以缓存行（Cache Line）为单位存储的，当多线程修改互相独立的变量时，
        如果这些变量恰好共享同一个缓存行，就会彼此影响（写回、无效化或者同步）而导致性能降低，这就是伪共享问题。
     解决方法
        设处理器的缓存行大小为64字节，一个卡表元素占1个字节，64个卡表元素将共享同一个缓存行。
        这64个卡表元素对应的卡页总的内存为32KB（64×512字节），也就是说如果不同线程更新的对
        象正好处于这32KB的内存区域内，就会导致更新卡表时正好写入同一个缓存行而影响性能。为了避免
        伪共享问题，一种简单的解决方案是不采用无条件的写屏障，而是先检查卡表标记，只有当该卡表元
        素未被标记过时才将其标记为变脏，即将卡表更新的逻辑变为以下代码所示：
#6、并发的可达性分析
    在根节点枚举这个步骤中，由于GC Roots相比整个Java堆中全部的对象毕竟还算是极少数，且在各种优化技巧（如OopMap）的加持下，
    它带来的停顿已经是非常短暂且相对固定（不随堆容量而增长）的了。可从GC Roots再继续往下遍历对象所停顿时间就必定会与
    Java堆容量直接成正比例关系了：堆越大，存储的对象越多，要标记更多对象而产生的停顿时间自然就更长，这听起来是理所当然的事
    
    让垃圾回收器和用户线程同时运行，并发工作。也就是我们说的并发标记的阶段。
    
    当且仅当以下两个条件同时满足时，会产生“对象消失”的问题，即原本应该是黑色的对象被误标为白色：
    ·赋值器插入了一条或多条从黑色对象到白色对象的新引用；（黑色对象不会被重新扫描）
    ·赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。 （他可能删除以后重新链接到其他的灰色节点）
    
    解决并发扫描时的对象消失问题，只需破坏这两个条件的任意一个即可
        增量更新 CMS
            黑色对象一旦新插入了指向白色对象的引用之后，它就变回灰色对象
        原始快照 G1 + Shenandoah
            原始快照破坏的是第二个条件，也就是说不管引用关系是否删除，都会按照扫描那一刻的对象图快照进行搜索。
            这样就保证了对象一定能在调用链上，【不过会有少量确实应该回收的存在】。
