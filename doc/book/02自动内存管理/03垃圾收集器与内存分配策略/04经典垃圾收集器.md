#1、Serial收集器
    是一个单线程工作的收集器，在它进行垃圾收集时，必须暂停其他所有工作线程，
    
    新生代才去标记-复制算法
    老年代才用标记-整理算法
    
    应用：
    Serial没有线程交互的开销，专心做垃圾收集有最高的单线程收集效率。在桌面的应用场景以及部分微服务应用中
    分配给虚拟机管理的内存一般来说并不会特别大，收集几十兆甚至一两百兆的新生代（仅仅是指新生代使用的
    内存，桌面应用甚少超过这个容量），垃圾收集的停顿时间完全可以控。
    
    它依然是HotSpot虚拟机运行在客户端模式下的默认新生代收集器。
    
#2、ParNew收集器
    器实质上是Serial收集器的多线程并行版本.
    
    它是不少运行在服务端模式下的HotSpot虚拟机,除了Serial收集器外，目前只有它能与CMS收集器配合工作。
    
    jdk9 以后，只能和cms搭配使用
#3、Parallel Scavenge
    Parallel Scavenge收集器也是一款新生代收集器，是基于标记-复制
    
    而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量（处理器用于运行用户代码的时间与处理器总消耗时间的比值，）
    要适合在后台运算而不需要太多交互的分析任务。
    
    -XX：MaxGCPauseMillis 最大垃圾收集停顿时间 设置的越小 新生代越小 吞吐量越低
    -XX：GCTimeRatio 设置吞吐量大小
#4、Serial Old收集器
    Serial Old是Serial收集器的老年代版本，单线程收集器，使用标记-整理算法
    应用场景：
        客户端模式下的HotSpot虚拟机使用。
        服务端模式下：
            一种是在JDK 5以及之前的版本中与Parallel Scavenge收集器搭配使用[1]，
            一种就是作为CMS收集器发生失败时的后备预案，在并发收集发生Concurrent Mode Failure时使用
#5、Parallel Old收集器
    Parallel Old是Parallel Scavenge收集器的老年代版本
    jdk6 才提供
    
    如果新生代选择了Parallel Scavenge收集器，老年代除了Serial Old（PSarkSweep）收集器以外别无选择，
    其他表现良好的老年代收集器，如CMS无法与它配合工作。由于老年代Serial Old收集器在服务端应用性能上的
    “拖累”，使用Parallel Scavenge收集器也未必能在整体上获得吞吐量最大化的效果
    
    直到Parallel Old收集器出现。
#6、CMS收集器（Concurrent Mark Sweep）
    是一种以获取最短回收停顿时间为目标的收集器，基于标记-清除算法实现的
    
    原理并发可达性分析：
    1）初始标记（CMS initial mark） 
        stop the world 
        只是标记一下GC Roots能直接关联到的对象，速度很快
    2）并发标记（CMS concurrent mark）
        这个过程耗时较长但是不需要停顿用户线程， 
    3）重新标记（CMS remark） 
        因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录（增量更新的），
        这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短；
    4）并发清除（CMS concurrent sweep）
        清理删除掉标记阶段判断的已经死亡的对象，不需要移动存活对象,可以与用户线程同时并发的。
    缺点：
        CMS收集器对处理器资源非常敏感,因为占用了一部分线程（处理器的计算能力）而导致应用程序变慢，
        于CMS收集器无法处理“浮动垃圾”（Floating Garbage）
        有大量空间碎片产生      

#7、Garbage First收集器
    Garbage First（简称G1）开创了收集器面向局部收集的设计思路和基于Region的内存布局形式
    
    逻辑分代，物理不分代。
    
    可以面向堆内存任何部分来组成回收集（Collection Set，一般简称CSet）进行回收衡量标准不再是它属于哪个分代，
    而是哪块内存中存放的垃圾数量最多，回收收益最大，这就是G1收集器的Mixed GC模式。
    
    G1不再坚持固定大小以及固定数量的分代区域划分，而是把连续的Java堆划分为多个【大小相等】的独立区域（Region），
    每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间

    Region中还有一类特殊的Humongous区域，专门用来存储大对象。
    
    G1收集器之所以能建立【可预测的停顿时间模型】，是因为它将Region作单次回收的最小单元，即每次收集到的内存
    空间都是Region大小的整数倍，这样可以有计划地避免在整个Java堆中进行全区域的垃圾收集。让G1收集器去跟踪各个Region里面的垃
    圾堆积的“价值”大小，然后在后台维护一个优先级列表，每次根据用户设定允许的收集停顿时间（使用参数-XX：MaxGCPauseMillis指定，默
    认值是200毫秒），优先处理回收价值收益最大的那些Region，这也就是“Garbage First”名字的由来。
    这种使用Region划分内存空间，以及具有优先级的区域回收方式，保证了G1收集器在有限的时间内获取尽可能高的收集效率
    
    
    需要解决的问题：
        Region里面存在的跨Region引用对象如何解决
            它的每个Region都维护有自己的记忆集，这些记忆集会记录下别的Region指向自己的指针，
        在并发标记阶段如何保证收集线程与用户线程互不干扰地运行
            
        怎样建立起可靠的停顿预测模型
        
    四个步骤：
        ·初始标记（Initial Marking）：
            仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS指针的值，让下一阶段用户线程并发运行时，
            能正确地在可用的Region中分配新对象。这个阶段需要停顿线程，但耗时很短，而且是借用进行Minor GC的时候同步完成的，
            所以G1收集器在这个阶段实际并没有额外的停顿。
          
        ·并发标记（Concurrent Marking）：
            从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，
            但可与用户程序并发执行。当对象图扫描完成以后，还要重新处理SATB记录下的在并发时有引用变动的对象。
        
        ·最终标记（Final Marking）：
            对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的最后那少量的SATB记录。
        
        ·筛选回收（Live Data Counting and Evacuation）：
            负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，
            可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧
            Region的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多条收集器线程并行完成的。
       
