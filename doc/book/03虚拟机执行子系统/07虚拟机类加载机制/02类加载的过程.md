#1、加载
    在加载阶段，Java虚拟机需要完成以下三件事情：
    1）通过一个类的全限定名来获取定义此类的二进制字节流。
    2）将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
    3）在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。
    
#2、验证
    这一阶段的目的是确保Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求，
    保证这些信息被当作代码运行后不会危害虚拟机自身的安全。
    
    1.文件格式验证
        ·是否以魔数0xCAFEBABE开头。
        ·主、次版本号是否在当前Java虚拟机接受范围之内。
        
    只有通过了这个阶段的验证之后，这段字节流才被允许进入Java虚拟机内存的方法区中进行存储，所以后面的三个验证阶段
    全部是基于方法区的存储结构上进行的，不会再直接读取、操作字节流了。
    
    2.元数据验证
        第二阶段是对字节码描述的信息进行语义分析
            ·这个类是否有父类（除了java.lang.Object之外，所有的类都应当有父类）。
            ·这个类的父类是否继承了不允许被继承的类（被final修饰的类）。
            ·如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。
    
    3.字节码验证
        主要目的是通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的。
        
    4.符号引用验证
        本阶段通常需要校验下列内容：
        ·符号引用中通过字符串描述的全限定名是否能找到对应的类。
        ·在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段。
        ·符号引用中的类、字段、方法的可访问性（private、protected、public、<package>）是否可被当
        前类访问
#3、准备
    准备阶段是正式为类中定义的变量（即静态变量）分配内存并设置类变量初始值的阶段，这些变量所使用的内存都应当在方法区中进行分配，
    
    这时候进行内存分配的仅包括类变量，而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。
    这里所说的初始值“通常情况”下是数据类型的零值，
    
    如果类字段的字段属性表中存在ConstantValue属性，那在准备阶段变量值就会被初始化为ConstantValue属性所指定
    的初始值，
    
#4、解析
    解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程，
    
#5、初始化
    初始化阶段就是执行类构造器<clinit>()方法的过程。<clinit>()并不是程序员在Java代码中直接编写
    的方法，它是Javac编译器的自动生成物，
    
    <clinit>()方法是由编译器自动收集类中的所有【类变量】的赋值动作和静态语句块（static{}块）中的
    语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序决定的，静态语句块中只能访问
    到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问
    
    
    <clinit>()方法与类的构造函数（即在虚拟机视角中的实例构造器<init>()方法）不同，它不需要显
    式地调用父类构造器，Java虚拟机会保证在子类的<clinit>()方法执行前父类的<clinit>()方法已经执行完毕。
#6、
