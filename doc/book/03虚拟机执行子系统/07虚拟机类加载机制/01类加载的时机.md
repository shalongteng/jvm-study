#0、概述
    与那些在编译时需要进行连接的语言不同，在Java里面，类型的加载、连接和初始化过程都是在程序运行期间完成
    的，这种策略让Java语言进行提前编译会面临额外的困难，
#1、类加载七个阶段
    加载（Loading）、
    验证（Verification）、
    准备（Preparation）、
    解析（Resolution）、
    初始化（Initialization）、
    使用（Using）
    和卸载（Unloading），
    
    其中验证、准备、解析三个部分统称为连接（Linking）。
    
    加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，类型的加载过程必须按照这种顺序按部就班地开始，
    而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持
    Java语言的运行时绑定特性（也称为动态绑定或晚期绑定）
#2、初始化时机
    1）遇到new、getstatic、putstatic或invokestatic这四条字节码指令时，如果类型没有进行过初始
    化，则需要先触发其初始化阶段。能够生成这四条指令的典型Java代码场景有：
    ·使用new关键字实例化对象的时候。
    ·读取或设置一个类型的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候。
    ·调用一个类型的静态方法的时候。
    2）使用java.lang.reflect包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需
    要先触发其初始化。
    
    3）当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
    4）当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。
    5）当使用JDK 7新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解
    析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句
    柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。
    6）当一个接口中定义了JDK 8新加入的默认方法（被default关键字修饰的接口方法）时，如果有
    这个接口的实现类发生了初始化，那该接口要在其之前被初始化。
    
#3。被动使用类字段演示
    对于静态字段，只有直接定义这个字段的类才会被初始化，过其子类来引用父类中定义的静态字段，只会触发
    父类的初始化而不会触发子类的初始化。
    
    通过数组定义来引用类，不会触发此类的初始化
    
    常量在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。
