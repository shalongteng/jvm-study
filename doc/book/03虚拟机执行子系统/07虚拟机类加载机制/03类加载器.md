#1、概念
    通过一个类的全限定名来获取描述该类的二进制字节流”。实现这个动 作的代码被称为“类加载器”（Class Loader）。
    
   
#2、类与类加载器
    只有同一个类加载器加载的类，才能比较是否相等。这里所指的“相等”，
    包括代表类的Class对象的equals()方法、isAssignableFrom()方法、isInstance()
    
#3、类加载器
    站在Java虚拟机的角度来看，只存在两种不同的类加载器：
        一种是启动类加载器（BootstrapClassLoader），这个类加载器使用C++语言实现，是虚拟机自身的一部分；
        一种是其他所有的类加载器，这些类加载器都由Java语言实现，
        
    启动类加载器（Bootstrap Class Loader）：
        负责加载存放在<JAVA_HOME>\lib目录，或者被-Xbootclasspath参数所指定的路径中存放的，
        用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器去处理，那直接使用null代替即可，
        java.lang.ClassLoader.getClassLoader()
        
    扩展类加载器（Extension Class Loader）：
        它负责加载<JAVA_HOME>\lib\ext目录中，或者被java.ext.dirs系统变量所指定的路径中所有的类库
        
        根据“扩展类加载器”这个名称，就可以推断出这是一种Java系统类库的扩展机制
        JDK的开发团队允许用户将具有通用性的类库放置在ext目录里以扩展Java SE的功能，
        
    应用程序类加载器（Application Class Loader）：
        由于应用程序类加载器是ClassLoader类中的getSystemClassLoader()方法的返回值，
        所以有些场合中也称它为“系统类加载器”。
        
        它负责加载用户类路径（ClassPath）上所有的类库，开发者同样可以直接在代码中使用这个类加载器。如果应用程序中没有
        自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。
        
    
#4、双亲委派模型
    如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，
    每一个层次的类加载器都是如此，因此所有的
    加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请
    求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。

#5、破坏双亲委派模型
    在OSGi环境下，类加载器不再双亲委派模型推荐的树状结构，而是进一步发展为更加复杂的网状结构，
    
    OSGi实现
        OSGi实现模块化热部署的关键是它自定义的类加载器机制的实现，每一个程序模块（OSGi中称为undle）都有一个自己的类加载器，
        B当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实现代码的热替换
       
