#1、对象优先在Eden分配
    大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起
    一次Minor GC。
    
#2、大对象直接进入老年代
    在Java虚拟机中要避免大对象的原因是，在分配空间时，它容易导致内存明明还有不少空间时就提前触发垃圾收集
    -XX:PretenureSizeThreshold=3145728 设置对象大于3MB时候，之间进入老年代。
#3、长期存活的对象将进入老年代
    虚拟机给每个对象定义了一个对象年龄（Age）计数器，存储在对象头中。对象通常在Eden区里诞生，如果经过第一次
    Minor GC后仍然存活，并且能被Survivor容纳的话，该对象会被移动到Survivor空间中，并且将其对象年龄设为1岁。
    对象在Survivor区中每熬过一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15），
    就会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数-XX：MaxTenuringThreshold设置
    
#4、动态对象年龄判定
    如果在Survivor空间中相同年龄所有对象大小的总和大于
    Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，
    
#5、空间分配担保
    在发生Minor GC之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，
    如果这个条件成立，那这一次Minor GC可以确保是安全的。
    
    如果不成立，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大
    于，将尝试进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，那这时就要改为进行一次Full GC。
