#1、根节点枚举 （找出根节点）
    调用栈里的引用类型数据是GC的根集合的重要组成部分，找出栈上的引用是GC的根枚举中不可或缺的一环。
    
    现在可达性分析算法耗时最长的查找引用链的过程已经可以做到与用户线程一起并发，
    但根节点枚举始终还是必须在一个能保障一致性的快照中才得以进行.所以这一步必须暂停用户线程。
    
    当用户线程停顿下来之后，其实并不需要一个不漏地检查完所有执行上下文和全局的引用位置，
    在HotSpot虚拟机里，是使用一组称为OopMap的数据结构来达到这个目的（这个oopMap 放的就是根节点引用）
        
    可以把oopMap简单理解成是调试信息。 在源代码里面每个变量都是有类型的，但是编译之后的代码就只有变量在栈上的位置了。
    oopMap就是一个附加的信息，告诉你栈上哪个位置本来是个什么东西
#2、安全点   safe point
    stw停业务线程时候，不是说所有的立马停止，因为有的线程正在对对象上锁呢，上了一半，这时候他不能停止。
    线程得停到一个合适的位置，停下来的时候，不会对前后的一致性产生影响。
    
    导致OopMap内容变化的指令非常多，
    
    实际上HotSpot也的确没有为每条指令都生成OopMap，前面已经提到，只是在“特定的位置”记录了这些信息，
    这些位置被称为安全点（Safepoint），用户线程强制达到安全点才能暂停。
    
    
    如何在垃圾收集发生时让所有线程（这里其实不包括执行JNI调用的线程）都跑到最近的安全点，然后停顿下来。
        抢先式中断 ： 系统主动中断用户线程，用户线程中断后，发现不在安全点自己跑到安全点
        主动式中断 ： 设一个标志位，线程去安全点轮询。如果需要中断则中断。
#3、安全区域
    用户线程处于Sleep状态或者Blocked状态，这时候线程无法响应虚拟机的中断请求。
    
    安全区域是指能够确保在某一段代码片段之中，引用关系不会发生变化，在这个区域中任意地方开始垃圾收集都是安全的。
    
    当线程要离开安全区域时，它要检查虚拟机是否已经完成了根节点枚举（或者垃圾收集过程中其他需要暂停用户线程的
    阶段），如果完成了，那线程就当作没事发生过，继续执行；否则它就必须一直等待，直到收到可以离开安全区域的信号为止。
    
#4、记忆集与卡表
    记忆集来缩减GC Roots扫描范围的问题
    
    为解决对象跨代引用所带来的问题，垃圾收集器在新生代中建立了名为记忆集（Remembered Set）的数据结构，
    用以避免把整个老年代加进GC Roots扫描范围。会给老年代分块，把有垮带引用的分到一起。
    
    记忆集是一种用于记录从非收集区域指向收集区域的指针集合的数据结构
    收集器只需要通过记忆集判断出某一块非收集区域是否存在有指向了收集区域的指针就可以了
    
    记录精度：
        ·字长精度：每个记录精确到一个机器字长（这个精度决定了机器访问物理内存地址的指针长度），该字包含跨代指针。
        ·对象精度：每个记录精确到一个对象，该对象里有字段含有跨代指针。
        ·卡精度：每个记录精确到一块内存区域，该区域内有对象含有跨代指针。
        
    第三种“卡精度”所指的是用一种称为“卡表”（Card Table）的方式去实现记忆集
        字节数组CARD_TABLE的每一个元素都对应着其标识的内存区域中一块特定大小的内存块，称作“卡页”（Card Page）512 字节
        
        一个卡页的内存中通常包含不止一个对象，只要卡页内有一个对象的字段存在着跨代指针，那就将对应卡表的数组元素的值标识为1，
        称为这个元素变脏（Dirty），没有则标识为0。在垃圾收集发生时，只要筛选出卡表中变脏的元素，把它们加入GC Roots中一并扫描。
#5、写屏障，读屏障
    当发现jvm在执行某一种操作时候，跟上去做一中背后的操作。
    在复制算法中。A-->B 这时候拷贝B对象到 另一个区域时候，需要把A重新指向B，任何一次垃圾移动对象以后
    都得更新引用，需要同步更新引用（写后屏障）post write barrier
    
    写屏障可以看作在虚拟机层面对“引用类型字段赋值”这个动作的AOP切 面
    更新卡表，对卡表进行维护。
    
#6、并发的可达性分析
    在根节点枚举这个步骤中，由于GC Roots相比整个Java堆中全部的对象毕竟还算是极少数，且在各种优化技巧（如OopMap）的加持下，
    它带来的停顿已经是非常短暂且相对固定（不随堆容量而增长）的了。可从GC Roots再继续往下遍历对象所停顿时间就必定会与
    Java堆容量直接成正比例关系了：堆越大，存储的对象越多，要标记更多对象而产生的停顿时间自然就更长，这听起来是理所当然的事
    
    让垃圾回收器和用户线程同时运行，并发工作。也就是我们说的并发标记的阶段。
    
    当且仅当以下两个条件同时满足时，会产生“对象消失”的问题，即原本应该是黑色的对象被误标为白色：
    ·赋值器插入了一条或多条从黑色对象到白色对象的新引用；（黑色对象不会被重新扫描）
    ·赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。 （他可能删除以后重新链接到其他的灰色节点）
    
    解决并发扫描时的对象消失问题，只需破坏这两个条件的任意一个即可
        增量更新 黑色对象一旦新插入了指向白色对象的引用之后，它就变回灰色对象
        原始快照 
